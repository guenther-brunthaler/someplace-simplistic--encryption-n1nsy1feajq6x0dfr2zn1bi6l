#! /bin/sh
version() {
	cat << ===
Version 2020.346

Copyright (c) 2020 Guenther Brunthaler. All rights reserved.

This script is free software.
Distribution is permitted under the terms of the GPLv3.
===
}

help() {
	cat << ===
$APP - POSIX shell/AWK implementation of the ARCFOUR stream cipher algorithm |
(with an extension for keys longer than 256 octets)|
|
Usage: $APP [ <options> ] [ -- ] <key_file>|
|
$APP reads binary (or text) data from standard input, encrypts or decrypts it |
using the contents of <key_file> as a binary encryption key, and writes the |
result to standard output.|
|
$APP implements an extension to the original key setup algorithm which only |
kicks in for keys longer than 256 octets: In this case, the remaining octets |
of the key will be processed in exactly the same way as the key octets |
before. Key setup will simply not stop after 256 key octets have been |
processed. Neither will it ignore the rest of the key as the original key |
setup would do.|
|
Options supported:|
|
-d <count>: Drop the initial <count> octets generated by the internal |
cryptographically secure pseudo random number generator (CSPRNG) of the |
stream cipher and do them not use for actual encryption/decryption. Defaults |
to 0. For instance, "-d 3072" (a choice recommended for better security) |
would make $APP actually implement the "ARCFOUR-drop3072" algorithm.|
|
-g <count>: Instead of encrypting/decrypting data read from standard input |
after key setup (which included honoring the -d option), just output the |
first <count> octets produced by the internal CSPRNG.|
|
-V: Show version information and exit.|
-h: Display this help and exit.|
|
$APP implements a stream cipher where encryption and decryption are the same |
operation: Applying it to plaintext produces ciphertext, applying it to |
ciphertext produces plaintext again. (Both times using the same key, of |
course)|
|
The -g option is particularly interesting in combination with the extended |
key setup, because it can be used to turn $APP into a deterministic pseudo |
random number generator which uses the contents of <key_file> as seed of |
arbitrary size.|
|
This can in turn be used for different purposes:|
|
* (pseudo-) random number generation|
* key stretching|
* salt stretching|
* key compaction|
* password-based key derivation (PBKDF)|
* hashing (cryptographically non-secure, though)|
===
}
APP=${0##*/}

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

show() {
	fold -sw 66
}

exit_version() {
	version | show; exit $1
}

exit_help() {
	help | sed 's/ |$/ /' | tr -d '\n' | tr '|' '\n' | show
	echo; exit_version "$@"
}

die() {
	echo "$*" >& 2
	false || exit
}

ckuint() {
	expr x"$OPTARG" = x0 '|' x"$OPTARG" : x'[1-9][0-9]*$' > /dev/null \
		|| die "Bad count '$OPTARG'!"
}

drop=0
generate=
while getopts d:g:hV opt
do
	case $opt in
		d) ckuint; drop=$OPTARG;;
		g) ckuint; generate=$OPTARG;;
		h) exit_help;;
		V) exit_version;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

case $# in
	1) ;;
	*) exit_help `false || echo $?` >& 2
esac

test -f "$1" || die "Binary key file '$1' not found!"

alias decdump='od -vt u1'

{
	decdump < "$1" | sed 's/^/K /'
	echo D $drop
	case $generate in
		'') decdump;;
		*) echo G $generate
	esac
} | awk -v failure=`false || echo $?` -f /dev/fd/5 5<< 'EOF'

# Globals:
# i, i1, i2, s[256], ki, kr[128], h42o[16], xor4[16, 16], o2h4[256], o2l4[256].

$1 == "K" { for (i= 3; i <= NF; ++i) append_key_octet($i); next }

$1 == "D" {
	check_number(i= $2); finish_key_setup()
	while (i--) dencrypt(0)
	next
}

$1 == "G" { check_number(i= $2); while (i--) print dencrypt(0); exit }

{ for (i= 2; i <= NF; ++i) {print "CRYPTED: " dencrypt($i)} }

BEGIN {
	for (i= 256; i--; ) s[i]= i
	make_lookup_tables()
	prepare(); ki= 0
}

function prepare() {
	i1= i2= 0
}

function append_key_octet(k    , t) {
	if (ki < 128) kr[ki]= k
	++ki
	i2= add_mod256(add_mod256(i2, s[i1]), k)
	t= s[i1]; s[i1]= s[i2]; s[i2]= t
	i1= add_mod256(i1, 1)
}

function finish_key_setup(    klen) {
	klen= ki
	for (i= 0; ki != 256; ) {
		append_key_octet(kr[i])
		if (++i == klen) i= 0
	}
	prepare()
}

function dencrypt(t    , v1, v2) {
	i1= add_mod256(i1, 1)
	i2= add_mod256(i2, s[i1])
	v1= s[i1]; s[i1]= v2= s[i2]; s[i2]= v1
	return xor8(t, s[add_mod256(v1, v2)])
}

function xor8(a, b) {
	return h42o[xor4[o2h4[a], o2h4[b]]] + xor4[o2l4[a], o2l4[b]]
}

function add_mod256(a, b    , s) {
	if ((s= a + b) < 256) return s
	return s - 256
}

# Set up h42o[16], xor4[16, 16], o2h4[256] and o2l4[256].
function make_lookup_tables(    s, j, o, b, c, t, l, r) {
	# Set up high-nybble to octet lookup table.
	for (i= 16; i--; ) h42o[i]= 16 * i
	# Set up octet to high- and low-nybble lookup tables.
	for (o= 256; o--; ) { o2h4[o]= int(o / 16); o2l4[o]= o % 16 }
	# Set up b[16, 4] for nybble to bits lookup table.
	for (i= 1; i < 16; ++i) {
		c= 1
		for (j= 0; j < 4; ++j) {
			if (c= (s= b[i - 1, j] + c) > 1) s-= 2
			b[i, j]= s
		}
	}
	# Setup XOR truth table t[2, 2].
	for (i= 2; i--; ) {
		for (j= 2; j--; ) t[i, j]= (i || j) && !(i && j)
	}
	# Setup XOR lookup table for nybble pairs.
	for (o= 0; o < 256; ++o) {
		l= o2h4[o]; r= o2l4[o]
		i= 1
		for (j= s= 0; j < 4; ++j) {
			if (t[b[l, j], b[r, j]]) s+= i
			i+= i
		}
		xor4[l, r]= s
		printf "xor[%#04x, %#04x]= %#04x\n", l, r, s
	}
}

function check_number(n    , n1) {
	n1= n + 1; n1-= n
	if ("x" n1 == "x1") return
	die("Numeric overflow for argument '" n "'!")
}

function die(msg) {
	print msg >> "/dev/stderr"
	exit failure
}

EOF
