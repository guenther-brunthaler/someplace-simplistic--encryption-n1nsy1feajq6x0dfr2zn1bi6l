#define VERSTR_1 "Version 2020.328"
#define VERSTR_2 "Copyright (c) 2020 Guenther Brunthaler."

static char help[]= { /* Formatted as 66 output columns. */
   "rc4drop3072 - ARCFOUR-drop3072 using keys of optimal fixed size\n"
   "\n"
   "The program encrypts binary data plaintext or decrypts binary\n"
   "data ciphertext and writes the binary result to standard output.\n"
   "Note that actual text data is a subset of binary data and will\n"
   "therefore also work as plaintext. Encryption and decryption are\n"
   "the same operation when using the ARCFOUR-drop3072 algorithm, so\n"
   "it depends on the input what actually happens.\n"
   "\n"
   "This program has no command line arguments. It reads everything\n"
   "required from it standard input in the following format:\n"
   "\n"
   "K<key211>T<data>\n"
   "\n"
   "where\n"
   "\n"
   "<key211>: 211 octets (binary 8-bit data bytes) encryption key\n"
   "<data>: arbitrary number of plaintext or ciphertext octets\n"
   "\n"
   "Note: 211 is ceiling(log2(256!) / 8)) and 256! is the number of\n"
   "possible distinct keys for ARCFOUR-drop3072. It is also the\n"
   "minimum number of key octets which covers the whole key space of\n"
   "ARCFOUR-drop3072.\n"
   "\n"
   "Also note that the same key must *never* be reused for different\n"
   "messages! Hash some password and a nonce (salt) to derive the\n"
   "actual key.\n"
   "\n"
   "Recommended: Sandwich the password (without any terminating\n"
   "newline) between two copies of a 32-octet random salt for key\n"
   "derivation and hash the whole thing with 'rc4hash -rb 211'. Put\n"
   "another copy of the salt as the first 32 octets into the\n"
   "encrypted file, allowing the salt to be retrieved from there for\n"
   "decryption.\n"
   "\n"
   "Suggestion: Consider using file extension '.r4s' for output files\n"
   "generated by this program.\n"
   "\n"
   "This program implements the ARCFOUR-drop3072 algorithm, which is\n"
   "the same as original ARCFOUR except that the first 3072 octets of\n"
   "the internally-generated keystream are dropped and thus not used\n"
   "for the actual encryption/decryption.\n"
   "\n"
   VERSTR_1 "\n"
   "\n"
   VERSTR_2 " All rights reserved.\n"
   "\n"
   "This program is free software.\n"
   "Distribution is permitted under the terms of the GPLv3."
};

#include "arc4_common.h"
#include <dim_sdbrke8ae851uitgzm4nv3ea2.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#define ASSERT_POWER_OF_2(n) assert(~((n) - 1) % (n) == 0)

int main(int argc, char **argv) {
   char const *error= 0;
   ARCFOUR_VARDEFS(static);
   /* Ensure SBOX_SIZE is an integral power of 2. */
   ASSERT_POWER_OF_2(SBOX_SIZE);
   if (argc > 1) { usage: error= help; goto fail; }
   (void)argv;
   if (getchar() != 'K') goto usage;
   /* Prepare key setup. */
   ARCFOUR_STEP_1;
   ARCFOUR_STEP_2;
   /* Process the fixed-size key. */
   {
      #define KEY_OCTETS 211
      unsigned n;
      for (n= 0; n < KEY_OCTETS; ++n) {
         static unsigned char recycle[SBOX_SIZE - KEY_OCTETS];
         int c;
         if (n > KEY_OCTETS) {
            /* Although key recycling is rather pointless in a "-drop3072"
             * scenario, we still do it in order to maintain compatibility
             * with the original ARCFOUR implementation. */
            assert((int)n - KEY_OCTETS >= 0);
            assert(n - KEY_OCTETS < DIM(recycle));
            c= recycle[n - KEY_OCTETS];
         } else {
            if ((c= getchar()) == EOF) goto usage;
            assert(c >= 0); assert(c < SBOX_SIZE);
            if (n < (unsigned)DIM(recycle)) recycle[n]= (unsigned char)c;
         }
         ARCFOUR_STEP_3;
         assert(c >= 0); assert(c < SBOX_SIZE);
         ARCFOUR_STEP_4_SETUP((unsigned)c);
         ARCFOUR_STEP_5_DROP;
      }
   }
   /* Finish key setup. */
   ARCFOUR_STEP_2;
   /* Drop the initial pseudorandom output. */
   {
      unsigned k;
      for (k= DROP_N; k--; ) {
         ARCFOUR_STEP_3; ARCFOUR_STEP_4; ARCFOUR_STEP_5_DROP;
      }
   }
   if (getchar() != 'T') goto usage;
   /* Encrypt or decrypt standard input to standard output. */
   {
      int c;
      while ((c= getchar()) != EOF) {
         ARCFOUR_STEP_3; ARCFOUR_STEP_4; ARCFOUR_STEP_5;
         assert(c >= 0); assert(c < SBOX_SIZE);
         c^= ARCFOUR_STEP_6();
         if (putchar(c) != c) goto wrerr;
      }
   }
   if (ferror(stdin)) { error= "Read error!"; goto fail; }
   assert(feof(stdin));
   if (fflush(0)) {
      wrerr: error= "Write error!";
      fail:
      (void)fputs(error, stderr);
      (void)fputc('\n', stderr);
   }
   return error ? EXIT_FAILURE : EXIT_SUCCESS;
}
