#! /bin/sh
version() {
	cat << ===
Version 2021.22

Copyright (c) 2021 Guenther Brunthaler. All rights reserved.

This script is free software.
Distribution is permitted under the terms of the GPLv3.
===
}

help() {
	cat << ===
$APP - use an s-box to transform the input data, and modify the s-box after|
every step|
|
Usage: $APP [ <options> ] [ -- ] < <input_stream>|
|
$APP reads ASCII words (separated by whitespace, including newline sequences)|
from standard input and interprets them according to one of the two following|
formats:|
|
E <key256> <pairs>|
|
D <key256> <pairs>|
|
where|
|
"E", "D": these literal one-character words represent themselves.|
|
<key256>: 256 decimal numbers in the range 0 through 255 (inclusive) which|
determine the initial setup of the s-box. They will be used as follows:|
Initially, the s-box (which is a array with 256 entries and its first index|
is 0) is set to the identity permutation, i. e. contains the numbers 0|
through 255. After that, all 256 numbers of <key256> are used to swap two|
s-box entries: The entry with index <i> and the entry with the index equal to|
the <i>th number of <key256>, where <i> runs from 0 through 255.|
|
"D" ... <pairs>: Decrypt all following input data, interpreting it as an|
arbitrary number of pairs of decimal numbers. The first number in every pair|
is a number to be decrypted, and the second number must have been created by|
a cryptographic pseudo-random generator. The decryption consists of emitting|
the current s-box value indexed by the first number. After this, the s-box|
entry just output is swapped with the s-box entry indexed by the second|
number of the pair. This process continues until all pairs have been|
processed, which stops at the end of the input data stream.|
|
"E" ... <pairs>: Exactly like "D", only that the reverse transformation is|
done, emitting the encrypted values of the decrypted first numbers in all the|
pairs. The second number must be the same as was used for decryption.|
Encryption requires more work than decryption and is therefore slower. This|
is a deliberate design decision, because data usually gets at least as often|
decrypted as it has been encrypted, and potentially more often. If this is|
not true for your application (i. e. encrypting backups), the "D" and "E"|
operations can be exchanged without security disadvantages: They are just the|
inverses of one another. It is not really important which of both|
transformation is used for encryption and which one for decryption.|
|
|
All "<...>" items explained above must be unsigned decimal integer numbers in |
ASCII encoding.|
|
The output of $APP will also be ASCII decimal number with 20 numbers per line |
(except for the last line which might be shorter).|
|
|
Options supported:|
|
-V: Show version information and exit.|
-h: Display this help and exit.|
|
|
This utility is intended to be used together with a companion utility which|
can interleave the data values to be encrypted with pseudorandom values|
generated by a cryptographically secure pseudo random generator. That utility|
can also prefix the interleaved data stream with 256 pseudorandom numbers to|
be used as <key256>.|
|
The output of this utility is intended to be used together with another|
companion utility which can convert the encrypted or decrypted decimal|
numbers into binary output data.|
===
}
APP=${0##*/}

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

show() {
	fold -sw 66
}

exit_version() {
	version | show; exit $1
}

exit_help() {
	help | sed 's/ |$/ /' | tr -d '\n' | tr '|' '\n' | show
	echo; exit_version "$@"
}

while getopts d:g:hV opt
do
	case $opt in
		h) exit_help;;
		V) exit_version;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

case $# in
	0) ;;
	*) exit_help `false || echo $?` >& 2
esac

awk -v failure=`false || echo $?` -f /dev/fd/5 5<< 'EOF'

# Globals: si, mode, oitems, oline, s[256], rs[256].

BEGIN {
	init_sbox(); si= 0
}

{
	for (i= 1; i <= NF; ++i) {
		if (mode == "D") {
			if (si < 0) si= $i; else emit(decrypt($i))
		} else if (mode == "E") {
			if (si < 0) si= $i; else emit(encrypt($i))
		} else if ($i ~ /^[DE]$/) {
			if (si) die("'D' or 'E' token must come first!")
			mode= "K" $i
		} else {
			append_key_octet($i)
			if (si == 256) {
				mode= substr(mode, 2)
				if (mode == "E") calc_rev_sbox()
				si= -1
			}
		}
	}
}

function encrypt(r    , c, rr, t) {
	c= rs[si]; rr= rs[r]
	t= s[c]; s[c]= s[r]; s[r]= t
	t= rs[rr]; rs[rr]= rs[si]; rs[si]= t
	si= -1; return c
}

function decrypt(r    , p) {
	p= s[si]; s[si]= s[r]; si= -1; return s[r]= p
}

function init_sbox(    i) {
	for (i= 256; i--; ) s[i]= i
}

function calc_rev_sbox(    i) {
	for (i= 256; i--; ) rs[s[i]]= i
}

function append_key_octet(k    , t) {
	t= s[si]; s[si++]= s[k]; s[k]= t
}

function emit(val) {
	if (oitems == 20) { print oline; oitems= 0 }
	oline= oitems++ ? oline " " val : val
}

END {
	if (oitems) print oline
}

function die(msg) {
	print msg >> "/dev/stderr"
	exit failure
}

EOF
