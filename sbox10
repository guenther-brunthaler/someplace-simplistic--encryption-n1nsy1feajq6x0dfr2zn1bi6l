#! /bin/sh
version() {
	cat << ===
Version 2021.22.3

Copyright (c) 2021 Guenther Brunthaler. All rights reserved.

This script is free software.
Distribution is permitted under the terms of the GPLv3.
===
}

help() {
	cat << ===
$APP - use an s-box to transform the input data, and modify the s-box after |
every step|
|
Usage: $APP [ <options> ] [ -- ] < <input_stream>|
|
$APP is an alternative "mode of operation" for stream ciphers which normally |
use bitwise XOR in order to combine the data to be encrypted or decrypted |
with the output of a cryptographically secure pseudo-random number generator. |
The latter approach is fast but poses many security challenges, in particular |
bit-flipping attacks and the danger of OTP recovery in case of repeated usage |
of the same key.|
|
An s-box transformation as provided by this utility avoids some of those |
shortcomings, and is therefore more secure.|
|
$APP reads ASCII words (separated by whitespace, including newline sequences) |
from standard input and interprets them according to one of the following |
format:|
|
<key256> <pairs>|
|
where|
|
<key256>: 256 decimal values in the range 0 through 255 (inclusive) which |
determine the initial setup of the s-box. They will be used as follows: |
Initially, the s-box (which is a array with 256 entries and its first index |
is 0) is set to the identity permutation, i. e. contains the values 0 through |
255. After that, all 256 values of <key256> are used to swap two s-box |
entries: The entry with index <i> and the entry with the index equal to the |
<i>th value of <key256>, where <i> runs from 0 through 255 (in that order).|
|
<pairs>: Transform (or inversely transform, selected by command line option) |
all following input data, interpreting it as an arbitrary number of decimal |
value pairs. The first value of every pair is a value to be transformed |
(back), and the second value must have been created by a cryptographically |
secure pseudo-random number generator. The tranformation consists of emitting |
the current s-box value indexed by the first value. After this, the s-box |
entry just output is swapped with the s-box entry indexed by the second value |
of the pair. The inverse transformation does the opposite of these steps. |
This process continues until all pairs have been transformed or been |
transformed back, which stops at the end of the input data stream.|
|
|
All "<...>" items explained above must be unsigned decimal integer numbers in |
ASCII encoding.|
|
The output of $APP will also be ASCII decimal number with 20 values per line |
(except for the last line which might be shorter).|
|
|
Options supported:|
|
-e: Apply the inverse transformation. This is slower. Normally used for |
encryption.|
-d: Apply the transformation. This is faster. Normally used for decryption.|
-V: Show version information and exit.|
-h: Display this help and exit.|
|
|
There is no real reason why -d applies the transformation and -e applies the |
inverse transformation. It could be the other way around as well. Both |
transformations just undo the effects of the other one. The decision to use |
the slower transformation for encryption has been made due to the observation |
that most data will be decrypted at least as often as it has been encrypted, |
and sometimes more often than that.|
|
However, there are scenarios where this does not necessarily apply, such as |
encrypting backups. Feel free to reverse the options -e and -d for such |
applications; this will have no adverse effect on the encryption security.|
|
This utility is intended to be used together with a companion utility |
"rc4csprng10" which can interleave the data values to be encrypted with |
pseudorandom values generated by a cryptographically secure pseudo random |
generator. That utility can also prefix the interleaved data stream with 256 |
pseudorandom values to be used as <key256>.|
|
The output of this utility is intended to be used together with another |
companion utility "dec2raw" which can convert the encrypted or decrypted |
decimal values into binary output data.|
===
}
APP=${0##*/}

set -e
trap 'test $? = 0 || echo "\"$0\" failed!" >& 2' 0

show() {
	fold -sw 66
}

exit_version() {
	version | show; exit $1
}

exit_help() {
	help | sed 's/ |$/ /' | tr -d '\n' | tr '|' '\n' | show
	echo; exit_version "$@"
}

mode=
while getopts dehV opt
do
	case $opt in
		e) mode=E;;
		d) mode=D;;
		h) exit_help;;
		V) exit_version;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

case $mode:$# in
	?:0) ;;
	*) exit_help `false || echo $?` >& 2
esac

awk -v mode=$mode -v failure=`false || echo $?` -f /dev/fd/5 5<< 'EOF'

# Globals: failure, phase, si, mode, oitems, oline, s[256], rs[256].

BEGIN {
	init_sbox(); si= 0; phase= "K"
}

{
	for (i= 1; i <= NF; ++i) {
		if (phase == "K") {
			append_key_octet($i)
			if (si == 256) {
				phase= "T"
				if (mode == "E") calc_rev_sbox()
				si= -1
			}
		} else if(mode == "D") {
			if (si < 0) si= $i; else emit(decrypt($i))
		} else {
			if (si < 0) si= $i; else emit(encrypt($i))
		}
	}
}

function encrypt(r    , c, t) {
	t= s[c= rs[si]]; s[c]= s[r]; s[r]= t
	rs[si]= r; si= -1; return rs[r]= c
}

function decrypt(r    , p) {
	p= s[si]; s[si]= s[r]; si= -1; return s[r]= p
}

function init_sbox(    i) {
	for (i= 256; i--; ) s[i]= i
}

function calc_rev_sbox(    i) {
	for (i= 256; i--; ) rs[s[i]]= i
}

function append_key_octet(k    , t) {
	t= s[si]; s[si++]= s[k]; s[k]= t
}

function emit(val) {
	if (oitems == 20) { print oline; oitems= 0 }
	oline= oitems++ ? oline " " val : val
}

END {
	if (oitems) print oline
}

function die(msg) {
	print msg >> "/dev/stderr"
	exit failure
}

EOF
