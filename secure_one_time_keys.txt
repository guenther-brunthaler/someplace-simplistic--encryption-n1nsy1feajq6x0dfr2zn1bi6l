Secure On-Time Keys
===================
Guenther Brunthaler
v2021.76

This guide shall establish some recommendations how to create one-time keys 
for situations where this is required for encryption.

For instance, it is a requirement for most stream ciphers which trivially 
combine a pseudorandom stream with the message to be encrypted as if the 
stream was a one-time-pad.

In such situations, where the same key will always regenerate the same "one 
time" pad, it is paramount that the keys will never repeat for a future 
message.

In order to accomplish this, we will combine a long-term key (which never or 
only rarely changes) with a nonce that is guaranteed to be different for very 
new message to be encrypted.

The combination can be simple: Just sandwich the long-term key between two 
copies of the nonce, and then use this either directly as the one-time key or 
hash it first and use the hash as the key.

The nonce shall be unique in space and time, but not necessarily in both. We 
will exploit this and compose the nonce having a constant space component and 
a unique time component.

The space component shall be created from the concatenation of the following 
strings:

* The constant text "user@host="
* the account name or its numeric ID
* an "@"-sign
* the fully-qualified host name (including all domain components, if known)

Using a different constant text, additional schemes may be devised later, such 
as GPS coordinates.

The time-component consist of

* The constant text "timestamp&counter="
* A timestamp in format "YYYY-MM-DD HH:MM:SS UTC" optionally followed by 
"+hhmm" or "-hhmm" for specifying a local time zone offset.
* an "&"-sign
* An ASCII decimal counter value, starting with 0 (or 1).

The counter *could* be reset every time the timestamp advances, but this is 
not recommended. Instead, it is recommended to increment the counter value for 
every new message and never repeat it within the same account.

If no time information is available, the "timestamp"-string in the constant 
text can be replaced with "low-quality-random-64-bit", and the timestamp can 
be replaced of a hexadecimal or base-64 encoding of a 64-bit low-quality 
random value which can be drawn from /dev/urandom. base-64 "="-padding 
characters can either be stripped or be left included. Also, the " " or ":" 
separating hexadecimal digits may be included or being stripped.

The counter should be incremented and stored permanently before it is used in 
order to be included within the time-component of the new nonce.

If the file containing the counter is read-only or cannot be read either, the 
constant text can be replaced with "full-entropy-random-256-bit=", and a 
256-bit high-quality random value which can be drawn from /dev/random shall 
follow the constant string, using the same representation choices as outlines 
for "random64".

If no random number sources are available of if they block too long for random 
extraction, the "haveged" daemon can be installed for creating some.

Other ways of random-generation are certainly possible, but outside the scope 
of this guide.
