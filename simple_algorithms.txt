Simple Cryptographic Algorithms
===============================
Guenther Brunthaler
v2022.70


Complexity is said to be the enemy of security.

This is true. Many theoretically perfectly safe implementations have successfully been attacked in practice due to bugs.

The likelihood for bugs, security-relevant or otherwise, increases with the complexity of the code as well as with its size.

Both issues can be tackled by modularization, but modularization has its own issues and is limited by the basic complexity of the algorithm.

In order to leave things as simple as possible, this project intends to use the simplest possible cryptographic primitives and combine them in ways which (hopefully) makes the result still cryptographically reasonably strong.

The primitives chosen are:

* The ARCFOUR algorithm (I refer to it as ARC4 for the sake of brevity in the remaining text)

* The Treyfer MAC algorithm

* TEA (optional)

There are improved versions of those algorithms, i.e. XXTEA instead of TEA. However, the improvements make the algorithms more complex and harder to understand, so I deliberately use the weaker but simpler original versions.

The basic idea is to combine simple not-so-safe algorithm, making the result much more secure. The goal is of course to make them sufficiently secure for practical use.

ARC4 has been chosen because it is one of the most straightforward and simple encryption algorithm known. It can quickly be explained how it works, and does not use strange constants. It is so simple that there is just no way of any algorithmic backdoor having been put there. It is only possible that the algorithm turns out to be really bad.

However, there has not been any proof of that yet. Event though many attacks on ARC4-encryption have been successful in the past, most of them exploited incorrect usage of the algorithm.

For instance, the keys used for ARC4 should be random. If a normal pass phrase is directly used, that can be bed.

Also, it is known that the initial portion of the pseudorandom bytestream generated by ARC4 (it is a stream cipher) is not very random and has statistical bias.

It has therefore been suggested to drop the initial 768 bytes (this is 3 times the size of the algorithm's internal s-box) of the pseudorandom stream for improved security.

Other sources recommend dropping the initial 3072 bytes (4 times more than 768 and 12 times the s-box size) for being much more conservatively, and so I follow that advice.

I will ARC4 also run in the SXS mode of operation, which stands for "subtract-XOR-subtract": Instead of just XORing one byte of the plaintext with one byte of the pseudorandom stream, we will subtract one byte of the pseudorandom stream first, then XOR a second byte in, and finally subtract a third byte. Decryption goes the reverse way, performing add-XOR-add.

On the plus side, ARC4 has a huge internal state and key space compared to most other contemporary encryption algorithms. Its key has an effective size of 1683 bits, even though the original algorithm supports keys up to 2048 bits.

ARC4 could also be made more secure by using a larger s-box, such as 2**16 or even 2**24 entries. But this would make the algorithm much slower due to the limited size of CPU caches and would also use more memory. I think the standard s-box size is safe enough.

If quantum computers might some day successfully attack symmetric cipher's based on Grover's algorithm, larger internal states will matter for improved resistance.

The Treyfer algorithm is basically a classical block encryption algorithm, only without a defined decryption operation.

Even though some clever people have managed to actually derive such a decryption operation, enhancing Treyfer into a full block cipher algorithm, the decryption algorithm is not easy to understand, and would therefore undermine the basic idea of simple building blocks.

I therefore do not make use of that decryption algorithm and use Treyfer as an encryption-only algorithm. This means one is restricted to modes of operation like OFB and CFB which do not need a decryption operation. However, this also turns Treyfer basically into a second stream cipher.

TEA on the other hand is a true block cipher. Unfortunately also a very weak one which is considered to be broken - when being used alone by itself.

The idea is to use ARC4 as the basic vehicle for security, and use Treyfer and TEA only to strengthen it a little. That little might not be much, but it should be enough to thwart any already-known attacks against ARC4 directly.

There is an attack against Treyfer called a "slide" attack which allows it to be broken with effort 2**44 independently of the matter of rounds. Which means adding more rounds will not maker it safer.

However, "slide" a known plaintext attack and requires 2**(N/2) plaintext-ciphertext pairs where N is the cipher block size.

Treyfer uses a 64 bit block and key size, and therefore only 2**32 pairs are required to crack it. Also, the key size of 64 bit is way too small for today's standards; this could even be broken by brute force along.

However, nothing in the structure of Treyfer forbids to increase the block size of the key size.

I therefore increase the block size to 512 bits, requiring 2**256 plaintext-ciphertext pairs for a successful slide attack which is infeasible.

I also increase to key size to 512 bit. Originally I considered increasing it just to 256 bit, because longer keys are not required even when being attacked with quantum computers. However, much in the design of the algorithm exploits the fact that the block size is the same as the key size. So the key is 512 bit also. If necessary, it is always possible to stretch a 256 bit key to 512 bit using various methods.

Treyfer will be run in CFB mode rather than OFB mode, because OFB mode might be susceptible for unknown fixed points in the mathematical function represented by the algorithm, which can never be ruled out. CFB combines the encryption with the data to be encrypted, so fixed points will not matter much or at least matter less.

TEA used a block size of 64 bit and a key size of 128 bit. The latter would be too insecure against quantum computer attacks, and the short blocks size is probably also a weakness.

The improved XXTEA algorithm would allow block sizes up to 416 bytes (it could actually be larger, but known attacks against XXTEA with larger block sizes discourage using them). The improved algorithm is also more complex, and it is still susceptible for a chosen-plaintext attack which could crack if with effort 2**59.

In other words, improving TEA only helps little, it must still considered to be broken.

Therefore I prefer using the original algorithm knowing that it is unsafe, not for "real" encryption but just for perturbing the output of ARC4 even more, after it has already been encrypted with Treyfer to "stir" its output.

Also, we are talking stream encryption here.

If I needed a random-access encryption such as for disk encryption, the combination of Treyfer and XXTEA would seen more attractive, perhaps also adding Chacha20 which is considered strong (although I have some doubts about it).

ChaCha20 ist a beautiful algorithm though, and not too complicated to implement. Perhaps I will eventually implement it as an additional encryption layer. However, its code size, although small compared to other state-of-the-art encryption algorithms, is still much larger than that of the beforementioned algorithms.

One algorithm still missing is a suitable string-to-key conversion procedure. Both ARC4 and TREYFER require quite random-looking keys for (reasonably) safe operation, and this human-provided pass phrases are not optimal and need preprocessing.

My idea is to use multiple iterations of TREYFER-512-CBC-MAC in order to convert a pass phrase into a 512 bit key.

We the interations with a key of all 0x55 octets and calculate the CBC-MAC over a message containing the pass phrase. The resulting MAC is then used as the key of the next iteration, which is calculated over the same kind of message. The MAC after the last iteration is the output of the algorithm which shall be used as a key.

The message over which the MAC shall be calculated consists of an initial 512 bit block containing the size of the pass phrase as a big-endian base-256 encoded number. This block is XORed with a iteration counter (starting at 0) encoded as a little-endian base-256 number. This initial block is followed by the pass phrase which is padded (if necessary) with trailig 0xaa octets into a multiple of 512 bits.

